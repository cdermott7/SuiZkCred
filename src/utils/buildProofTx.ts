import { TransactionBlock } from '@mysten/sui.js/transactions';
import { CredentialType } from '../../circuits/generateProof';

/**
 * Serializes proof data for on-chain verification
 * @param proof The ZK proof structure generated by snarkjs
 * @returns Serialized proof points
 */
function serializeProof(proof: any): Uint8Array[] {
  // In a real implementation, we'd properly serialize the snarkjs proof structure
  // For this demo, we'll create a simplified version with placeholders
  const proofA = new TextEncoder().encode(JSON.stringify(proof.pi_a || []));
  const proofB = new TextEncoder().encode(JSON.stringify(proof.pi_b || []));
  const proofC = new TextEncoder().encode(JSON.stringify(proof.pi_c || []));
  
  return [proofA, proofB, proofC];
}

/**
 * Serializes public inputs for on-chain verification
 * @param publicSignals The public signals from the ZK proof
 * @returns Serialized public inputs
 */
function serializePublicInputs(publicSignals: string[]): Uint8Array[] {
  return publicSignals.map(signal => new TextEncoder().encode(signal));
}

/**
 * Build a transaction to mint a credential with a proof and nullifier
 * @param proof The ZK proof in JSON format
 * @param publicSignals The public signals from the ZK proof
 * @param nullifier The nullifier value generated from the proof
 * @param credentialType The type of credential being minted
 * @param metadata Encrypted metadata for the credential
 * @param packageId The package ID of the deployed Move module
 * @param registryId The object ID of the nullifier registry
 * @returns Transaction object ready for signing
 */
export function buildProofAndMintTx(
  proof: any,
  publicSignals: string[],
  nullifier: string,
  credentialType: CredentialType,
  metadata: string,
  packageId: string = process.env.NEXT_PUBLIC_PACKAGE_ID || '0x0',
  registryId: string = process.env.NEXT_PUBLIC_REGISTRY_ID || '0x0'
): TransactionBlock {
  // Convert nullifier to bytes
  const nullifierBytes = Array.from(new TextEncoder().encode(nullifier));
  
  // Serialize the proof and public inputs
  const serializedProof = serializeProof(proof);
  const serializedPublicInputs = serializePublicInputs(publicSignals);
  
  // Placeholder verification key (in production, this would be the actual verification key)
  const verificationKey = Array.from(new TextEncoder().encode("demo_verification_key"));
  
  // Convert metadata to bytes (in a real app, this would be encrypted)
  const metadataBytes = Array.from(new TextEncoder().encode(metadata));
  
  // Issuer address (in production, this would be the actual issuer's address)
  // Using first 32 bytes of nullifier as a demo issuer address
  const issuerAddress = `0x${nullifier.substring(0, 64)}`;
  
  // Set expiration to 1 year from now
  const expirationTimestamp = Math.floor(Date.now() / 1000) + 365 * 24 * 60 * 60;
  
  // Create new transaction block
  const tx = new TransactionBlock();
  
  // Call the mint_and_transfer function on the SuiZkCred module
  tx.moveCall({
    target: `${packageId}::credential::mint_and_transfer`,
    arguments: [
      tx.pure(nullifierBytes),
      tx.pure(serializedPublicInputs),
      tx.pure(serializedProof),
      tx.pure(verificationKey),
      tx.pure(Number(credentialType)),
      tx.pure(issuerAddress),
      tx.pure(expirationTimestamp),
      tx.pure(metadataBytes),
      tx.object(registryId),  // Reference to shared nullifier registry
      tx.pure([]),  // Type arguments (none needed)
    ],
  });
  
  return tx;
}

/**
 * Verify a credential on-chain
 * @param credentialId The object ID of the credential to verify
 * @param revocationRegistryId The object ID of the revocation registry
 * @param packageId The package ID of the deployed Move module
 * @returns Transaction object for the verification 
 */
export function buildVerifyCredentialTx(
  credentialId: string,
  revocationRegistryId: string,
  packageId: string = process.env.NEXT_PUBLIC_PACKAGE_ID || '0x0'
): TransactionBlock {
  const tx = new TransactionBlock();
  
  // Call the verify function
  tx.moveCall({
    target: `${packageId}::credential::verify`,
    arguments: [
      tx.object(credentialId),
      tx.object(revocationRegistryId),
      tx.pure([]),  // Type arguments (none needed)
    ],
  });
  
  return tx;
}

/**
 * Build a transaction to revoke a credential
 * @param credentialId The object ID of the credential to revoke
 * @param packageId The package ID of the deployed Move module
 * @returns Transaction object for the revocation
 */
export function buildRevokeCredentialTx(
  credentialId: string,
  packageId: string = process.env.NEXT_PUBLIC_PACKAGE_ID || '0x0'
): TransactionBlock {
  const tx = new TransactionBlock();
  
  // Call the revoke_credential function
  tx.moveCall({
    target: `${packageId}::credential::revoke_credential`,
    arguments: [
      tx.object(credentialId),
      tx.pure([]),  // Type arguments (none needed)
    ],
  });
  
  return tx;
}

/**
 * Build a transaction to update the revocation Merkle root
 * @param registryId The object ID of the revocation registry
 * @param newRoot The new Merkle root
 * @param packageId The package ID of the deployed Move module
 * @returns Transaction object for updating the Merkle root
 */
export function buildUpdateRevocationRootTx(
  registryId: string,
  newRoot: Uint8Array,
  packageId: string = process.env.NEXT_PUBLIC_PACKAGE_ID || '0x0'
): TransactionBlock {
  const tx = new TransactionBlock();
  
  // Call the update_revocation_merkle_root function
  tx.moveCall({
    target: `${packageId}::credential::update_revocation_merkle_root`,
    arguments: [
      tx.object(registryId),
      tx.pure(Array.from(newRoot)),
      tx.pure([]),  // Type arguments (none needed)
    ],
  });
  
  return tx;
}