import { TransactionBlock } from '@mysten/sui.js/transactions';
import { CredentialType } from '../../circuits/generateProof';
import { generateNullifier } from './contractSetup';

/**
 * Serializes proof data for on-chain verification
 * @param proof The ZK proof structure generated by snarkjs
 * @returns Serialized proof points
 */
function serializeProof(proof: any): Uint8Array[] {
  // In a real implementation, we'd properly serialize the snarkjs proof structure
  // For this demo, we'll create a simplified version with placeholders
  const proofA = new TextEncoder().encode(JSON.stringify(proof.pi_a || []));
  const proofB = new TextEncoder().encode(JSON.stringify(proof.pi_b || []));
  const proofC = new TextEncoder().encode(JSON.stringify(proof.pi_c || []));
  
  return [proofA, proofB, proofC];
}

/**
 * Serializes public inputs for on-chain verification
 * @param publicSignals The public signals from the ZK proof
 * @returns Serialized public inputs
 */
function serializePublicInputs(publicSignals: string[]): Uint8Array[] {
  return publicSignals.map(signal => new TextEncoder().encode(signal));
}

/**
 * Build a transaction to mint a credential with a proof and nullifier
 * @param proof The ZK proof in JSON format
 * @param publicSignals The public signals from the ZK proof
 * @param nullifier The nullifier value generated from the proof
 * @param credentialType The type of credential being minted
 * @param metadata Encrypted metadata for the credential
 * @param packageId The package ID of the deployed Move module
 * @param registryId The object ID of the nullifier registry
 * @returns Transaction object ready for signing
 */
export function buildProofAndMintTx(
  proof: any,
  publicSignals: string[],
  nullifier: string,
  credentialType: CredentialType,
  metadata: string,
  packageId: string = process.env.NEXT_PUBLIC_PACKAGE_ID || '0x18a2f5290fa353c2b0a6518232e689d613b5b0cae8295bbb8d805d60cf56a3aa',
  registryId: string = process.env.NEXT_PUBLIC_REGISTRY_ID || '0x0'
): TransactionBlock {
  // Convert nullifier to bytes
  const nullifierBytes = Array.from(new TextEncoder().encode(nullifier));
  
  // Serialize the proof and public inputs
  const serializedProof = serializeProof(proof);
  const serializedPublicInputs = serializePublicInputs(publicSignals);
  
  // Placeholder verification key (in production, this would be the actual verification key)
  const verificationKey = Array.from(new TextEncoder().encode("demo_verification_key"));
  
  // Convert metadata to bytes (in a real app, this would be encrypted)
  const metadataBytes = Array.from(new TextEncoder().encode(metadata));
  
  // Issuer address (in production, this would be the actual issuer's address)
  // Using first 32 bytes of nullifier as a demo issuer address
  const issuerAddress = `0x${nullifier.substring(0, 64)}`;
  
  // Set expiration to 1 year from now
  const expirationTimestamp = Math.floor(Date.now() / 1000) + 365 * 24 * 60 * 60;
  
  // Create new transaction block
  const tx = new TransactionBlock();
  
  // Call the verify_and_mint function on the CredentialVerifier module
  tx.moveCall({
    target: `${packageId}::CredentialVerifier::verify_and_mint`,
    arguments: [
      tx.object(process.env.NEXT_PUBLIC_VERIFICATION_KEY_ID || '0x0'), // VerifierKey object
      tx.object(registryId), // RevocationRegistry object
      tx.pure(Array.from(serializedProof[0])), // proof_bytes as vector<u8>
      tx.pure(Array.from(serializedPublicInputs[0])), // inputs_bytes as vector<u8>
      tx.pure(generateNullifier(nullifier)), // nullifier as u64
      tx.pure(Number(credentialType)), // cred_type
      tx.pure(expirationTimestamp), // expires
      tx.pure(Math.floor(Date.now() / 1000)), // now_ts
    ],
  });
  
  return tx;
}

/**
 * Verify a credential on-chain
 * @param credentialId The object ID of the credential to verify
 * @param revocationRegistryId The object ID of the revocation registry
 * @param packageId The package ID of the deployed Move module
 * @returns Transaction object for the verification 
 */
export function buildVerifyCredentialTx(
  credentialId: string,
  revocationRegistryId: string,
  packageId: string = process.env.NEXT_PUBLIC_PACKAGE_ID || '0x18a2f5290fa353c2b0a6518232e689d613b5b0cae8295bbb8d805d60cf56a3aa'
): TransactionBlock {
  const tx = new TransactionBlock();
  
  // Call the is_valid function
  tx.moveCall({
    target: `${packageId}::CredentialVerifier::is_valid`,
    arguments: [
      tx.object(credentialId), // Credential object
      tx.object(revocationRegistryId), // RevocationRegistry object
      tx.pure(Math.floor(Date.now() / 1000)), // now_ts
    ],
  });
  
  return tx;
}

/**
 * Build a transaction to revoke a credential
 * @param credentialId The object ID of the credential to revoke
 * @param packageId The package ID of the deployed Move module
 * @returns Transaction object for the revocation
 */
export function buildRevokeCredentialTx(
  credentialId: string,
  packageId: string = process.env.NEXT_PUBLIC_PACKAGE_ID || '0x18a2f5290fa353c2b0a6518232e689d613b5b0cae8295bbb8d805d60cf56a3aa'
): TransactionBlock {
  const tx = new TransactionBlock();
  
  // Call the revoke_credential function
  tx.moveCall({
    target: `${packageId}::CredentialVerifier::revoke_credential`,
    arguments: [
      tx.object(credentialId), // Credential object
      tx.object(process.env.NEXT_PUBLIC_REGISTRY_ID || '0x0'), // RevocationRegistry object
    ],
  });
  
  return tx;
}

/**
 * Build a transaction to update the revocation Merkle root
 * @param registryId The object ID of the revocation registry
 * @param newRoot The new Merkle root
 * @param packageId The package ID of the deployed Move module
 * @returns Transaction object for updating the Merkle root
 */
export function buildUpdateRevocationRootTx(
  registryId: string,
  newRoot: Uint8Array,
  packageId: string = process.env.NEXT_PUBLIC_PACKAGE_ID || '0x18a2f5290fa353c2b0a6518232e689d613b5b0cae8295bbb8d805d60cf56a3aa'
): TransactionBlock {
  const tx = new TransactionBlock();
  
  // Note: The deployed contract uses a simple table-based revocation system
  // This function is not available in the current contract
  // Keeping for compatibility but will not work with current deployment
  tx.moveCall({
    target: `${packageId}::CredentialVerifier::verify_and_mint`,
    arguments: [
      tx.object(process.env.NEXT_PUBLIC_VERIFICATION_KEY_ID || '0x0'),
      tx.object(registryId),
      tx.pure([]),
      tx.pure([]),
      tx.pure(0),
      tx.pure(1),
      tx.pure(Math.floor(Date.now() / 1000) + 3600),
      tx.pure(Math.floor(Date.now() / 1000)),
    ],
  });
  
  return tx;
}